(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{442:function(t,a,e){"use strict";e.r(a);var s=e(14),i=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"mybatis-架构概览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mybatis-架构概览"}},[t._v("#")]),t._v(" MyBatis 架构概览")]),t._v(" "),e("p",[t._v("MyBatis 框架整体设计如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Willis-zzx/PicGO/img/202203132102929.png",alt:"img"}})]),t._v(" "),e("h3",{attrs:{id:"接口层-和数据库交互的方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接口层-和数据库交互的方式"}},[t._v("#")]),t._v(" 接口层  ——  和数据库交互的方式")]),t._v(" "),e("p",[t._v("MyBatis 和数据库的交互方式有两种：")]),t._v(" "),e("ul",[e("li",[t._v("使用传统的 MyBatis 提供的 API；")]),t._v(" "),e("li",[t._v("使用 Mapper 接口")])]),t._v(" "),e("h4",{attrs:{id:"使用传统的-mybatis-提供的-api-接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用传统的-mybatis-提供的-api-接口"}},[t._v("#")]),t._v(" 使用传统的 MyBatis 提供的 API 接口")]),t._v(" "),e("p",[t._v("这是传统的传递 Statement Id 和查询参数给 SqlSession 对象，使用 SqlSession对象完成和数据库的交互；")]),t._v(" "),e("p",[t._v("MyBatis 提供了非常方便和简单的 API，供用户实现对数据库的增删改查数据操作，以及对数据库连接信息和 MyBatis 自身配置信息的维护操作。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Willis-zzx/PicGO/img/202203132104773.png",alt:"img"}})]),t._v(" "),e("p",[t._v("上述使用 MyBatis 的方法，是创建一个和数据库打交道的 SqlSession 对象，然后根据 Statement Id 和参数来操作数据库，这种方式固然很简单和实用，但是它不符合面向对象语言的概念和面向接口编程的编程习惯。由于面向接口的编程是面向对象的大趋势，MyBatis 为了适应这一趋势，增加了第二种使用 MyBatis 支持接口（Interface）调用方式。")]),t._v(" "),e("h4",{attrs:{id:"使用-mapper-接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-mapper-接口"}},[t._v("#")]),t._v(" 使用 Mapper 接口")]),t._v(" "),e("p",[t._v("MyBatis 将配置文件中的每一个 "),e("code",[t._v("<mapper>")]),t._v(" 节点抽象为一个 Mapper 接口，而这个接口中声明的方法和 "),e("code",[t._v("<mapper>")]),t._v(" 节点中的 <select|update|delete|insert> 节点项对应，")]),t._v(" "),e("p",[t._v("即：")]),t._v(" "),e("ul",[e("li",[t._v("<select|update|delete|insert>  节点的 id 值为 Mapper 接口中的方法名称；")]),t._v(" "),e("li",[t._v("parameterType 值表示 Mapper 对应方法的入参类型；")]),t._v(" "),e("li",[t._v("resultMap 值对应 Mapper 接口表示的返回值类型或者返回结果集的元素类型。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Willis-zzx/PicGO/img/202203132109609.png",alt:"img"}})]),t._v(" "),e("p",[t._v('根据 MyBatis 的配置规范配置好后，通过 SqlSession.getMapper(XXXMapper.class) 方法，MyBatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个 Mapper 实例，我们使用 Mapper 接口的某一个方法时，MyBatis 会根据这个方法的方法名和参数类型，确定 Statement Id，底层还是通过 SqlSession.select("statementId",parameterObject); 或者SqlSession.update("statementId",parameterObject);  等等来实现对数据库的操作，MyBatis 引用 Mapper 接口这种调用方式，纯粹是为了满足面向接口编程的需要。（其实还有一个原因是在于：面向接口的编程，使得用户在接口上可以使用注解来配置 SQL 语句，这样就可以脱离 XML 配置文件，实现“0配置”）。')]),t._v(" "),e("h3",{attrs:{id:"数据处理层"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据处理层"}},[t._v("#")]),t._v(" 数据处理层")]),t._v(" "),e("p",[t._v("数据处理层可以说是 MyBatis 的核心，从大的方面上讲，它主要完成两个功能：")]),t._v(" "),e("ul",[e("li",[t._v("通过传入参数构建动态 SQL 语句；")]),t._v(" "),e("li",[t._v("SQL 语句的执行以及封装查询结果集 "),e("code",[t._v("Lsit<E>")])])]),t._v(" "),e("h4",{attrs:{id:"参数映射和动态-sql-语句生成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参数映射和动态-sql-语句生成"}},[t._v("#")]),t._v(" 参数映射和动态 SQL 语句生成")]),t._v(" "),e("p",[t._v("动态语句生成可以说是 MyBatis 框架非常优雅的一个设计，MyBatis 通过传入的参数值，使用 Ognl 来动态构造 SQL 语句，使得 MyBatis 有很强的灵活性和扩展性。")]),t._v(" "),e("p",[t._v("参数映射指的是对于 Java 数据类型和 JDBC 数据类型之间的转换，这里包括两个过程：")]),t._v(" "),e("ul",[e("li",[t._v("查询阶段，要将 Java 类型的数据，转换成 JDBC 类型的数据，通过 preparedStatement.setXXX() 来设值；")]),t._v(" "),e("li",[t._v("另一个是对 resultSet 查询结果集的 JDBCType 数据类型转换成 Java 数据类型。")])]),t._v(" "),e("h4",{attrs:{id:"sql-语句的执行以及封装查询结果集成-list"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sql-语句的执行以及封装查询结果集成-list"}},[t._v("#")]),t._v(" SQL 语句的执行以及封装查询结果集成 List")]),t._v(" "),e("p",[t._v("动态 SQL 语句生成之后，MyBatis 将执行 SQL 语句，并将可能返回的结果集转换成 "),e("code",[t._v("List<E>")]),t._v(" 列表。MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式：嵌套查询语句的查询  和 嵌套结果集的查询。")]),t._v(" "),e("h3",{attrs:{id:"框架支撑层"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#框架支撑层"}},[t._v("#")]),t._v(" 框架支撑层")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("事务管理机制")]),t._v(" "),e("p",[t._v("事务管理机制对于 ORM 框架而言是必不可少的一部分，事务管理机制的质量也是考量一个 ORM 框架是否优秀的一个标准。")])]),t._v(" "),e("li",[e("p",[t._v("连接池管理机制")]),t._v(" "),e("p",[t._v("由于创建一个数据库连接所占用的资源比较大，对于数据吞吐量大和访问量非常大的应用而言，连接池的设计就显得非常重要。")])]),t._v(" "),e("li",[e("p",[t._v("缓存机制")]),t._v(" "),e("p",[t._v("为了提高数据利用率和减少服务器、数据库的压力，MyBatis 会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到 SqlSession 中，在允许的时间间隔内，对于完全相同的查询，MyBatis 会直接将缓存结果返回给用户，而不用再到数据库中查找。")])]),t._v(" "),e("li",[e("p",[t._v("SQL 语句的配置方式")]),t._v(" "),e("p",[t._v("传统的 MyBatis 配置 SQL 语句方式就是使用 XML 文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，为了支持面向接口的编程，MyBatis 引入了 Mapper 接口的概念，面向接口的引入，对使用注解来配置 SQL 语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置 XML 文件了，但是，目前的 MyBatis 只是对注解配置 SQL 语句提供了有限的支持，某些高级功能还是要依赖 XML 配置文件来配置 SQL 语句。")])])]),t._v(" "),e("h3",{attrs:{id:"引导层"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引导层"}},[t._v("#")]),t._v(" 引导层")]),t._v(" "),e("p",[t._v("引导层是配置和启动 MyBatis 配置信息的方式。MyBatis 提供两种方式来引导 MyBatis：")]),t._v(" "),e("ul",[e("li",[t._v("基于 XML 配置文件的方式；")]),t._v(" "),e("li",[t._v("基于 Java API 的方式。")])]),t._v(" "),e("h2",{attrs:{id:"主要构件及其相互关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主要构件及其相互关系"}},[t._v("#")]),t._v(" 主要构件及其相互关系")]),t._v(" "),e("p",[t._v("从MyBatis 代码实现的角度来看，主体构件和关系如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Willis-zzx/PicGO/img/202203141637161.png",alt:"img"}})]),t._v(" "),e("p",[t._v("主要的核心部件解释如下：")]),t._v(" "),e("ul",[e("li",[t._v("SqlSession：作为 MyBAtis 工作的主要顶层 API，表示和数据库交互的会话，完成必要数据库增删改查功能。")]),t._v(" "),e("li",[t._v("Executor：MyBatis 执行器，是 MyBatis 调度的核心，负责 SQL 语句的生成和查询缓存的维护。")]),t._v(" "),e("li",[t._v("StatementHandler：封装了 JDBC Statement 操作，负责对 JDBC Statement 的操作，如设置参数、将 Statement 结果集转换成 List 集合。")]),t._v(" "),e("li",[t._v("ParameterHandler：负责对用户传递的参数转换成 JDBC Statement 所需的参数。")]),t._v(" "),e("li",[t._v("ResultSetHandler：负责将 JDBC 返回的 ResultSet 结果集对象转换成 List 类型的集合。")]),t._v(" "),e("li",[t._v("TypeHandler：负责 Java 数据类型和 JDBC 数据类型之前的映射和转换。")]),t._v(" "),e("li",[t._v("MappedStatement：MappedStatement 维护了一条 "),e("code",[t._v("<select|update|delete|insert>")]),t._v(" 节点的封装。")]),t._v(" "),e("li",[t._v("SqlSource：负责根据用户传递的 parameterObject ，动态生成 SQL 语句，将信息封装到 BoundSql 对象中，并返回。")]),t._v(" "),e("li",[t._v("Configuration：MyBatis 所有的配置信息都维持在 Configuration 对象中。")])])])}),[],!1,null,null,null);a.default=i.exports}}]);