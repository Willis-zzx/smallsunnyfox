(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{459:function(a,e,t){"use strict";t.r(e);var _=t(14),v=Object(_.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"一、java-集合概览"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、java-集合概览"}},[a._v("#")]),a._v(" 一、Java 集合概览")]),a._v(" "),t("p",[a._v("Java 集合，也叫做容器，主要是由两大接口派生而来：")]),a._v(" "),t("ul",[t("li",[a._v("一个是Collection接口，主要存放单一元素；")]),a._v(" "),t("li",[a._v("另一个是Map接口，主要用于存放键值对。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Willis-zzx/PicGO/img/202202262244549.png",alt:""}})]),a._v(" "),t("h2",{attrs:{id:"二、collection"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、collection"}},[a._v("#")]),a._v(" 二、Collection")]),a._v(" "),t("h3",{attrs:{id:"_2-1-set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-set"}},[a._v("#")]),a._v(" 2.1 Set")]),a._v(" "),t("h4",{attrs:{id:"treeset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#treeset"}},[a._v("#")]),a._v(" TreeSet")]),a._v(" "),t("p",[a._v("基于红黑树实现，支持有序操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet。")]),a._v(" "),t("h4",{attrs:{id:"hashset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashset"}},[a._v("#")]),a._v(" HashSet")]),a._v(" "),t("p",[a._v("基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说用 Iterator 遍历 HashSet 得到的结果是不确定的。")]),a._v(" "),t("p",[a._v("Set 接口对象存放数据是无序的，即添加的顺序和取出的顺序不一致。")]),a._v(" "),t("p",[a._v("取出的顺序虽然不是添加的顺序，但取出顺序是固定的。")]),a._v(" "),t("h4",{attrs:{id:"linkedhashset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashset"}},[a._v("#")]),a._v(" LinkedHashSet")]),a._v(" "),t("p",[a._v("具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。")]),a._v(" "),t("h3",{attrs:{id:"_2-2-list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-list"}},[a._v("#")]),a._v(" 2.2 List")]),a._v(" "),t("h4",{attrs:{id:"arraylist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[a._v("#")]),a._v(" ArrayList")]),a._v(" "),t("p",[a._v("基于动态数组实现，支持随机访问。")]),a._v(" "),t("h4",{attrs:{id:"vector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vector"}},[a._v("#")]),a._v(" Vector")]),a._v(" "),t("p",[a._v("和 ArrayList 类似，但它是线程安全的。")]),a._v(" "),t("h4",{attrs:{id:"linkedlist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[a._v("#")]),a._v(" LinkedList")]),a._v(" "),t("p",[a._v("基于双向链表实现，只能顺序访问，但是可以快速地在链表中插入和删除元素。")]),a._v(" "),t("p",[a._v("不仅如此，LinkedList 还可以用作栈、队列和双向队列。")]),a._v(" "),t("h3",{attrs:{id:"_2-3-queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-queue"}},[a._v("#")]),a._v(" 2.3 Queue")]),a._v(" "),t("h4",{attrs:{id:"linkedlist-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist-2"}},[a._v("#")]),a._v(" LinkedList")]),a._v(" "),t("p",[a._v("可以用它来实现双向队列。")]),a._v(" "),t("h4",{attrs:{id:"priorityqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#priorityqueue"}},[a._v("#")]),a._v(" PriorityQueue")]),a._v(" "),t("p",[a._v("基于堆结构实现，可以用它来实现优先队列。")]),a._v(" "),t("h2",{attrs:{id:"三、map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、map"}},[a._v("#")]),a._v(" 三、Map")]),a._v(" "),t("h3",{attrs:{id:"_3-1-treemap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-treemap"}},[a._v("#")]),a._v(" 3.1 TreeMap")]),a._v(" "),t("p",[a._v("基于红黑树实现。")]),a._v(" "),t("h3",{attrs:{id:"_3-2-hashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-hashmap"}},[a._v("#")]),a._v(" 3.2 HashMap")]),a._v(" "),t("p",[a._v("基于哈希表实现。")]),a._v(" "),t("h3",{attrs:{id:"_3-3-hashtable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-hashtable"}},[a._v("#")]),a._v(" 3.3 HashTable")]),a._v(" "),t("p",[a._v("和 HashMap 类似，但它是线程安全，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。")]),a._v(" "),t("p",[a._v("它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。")]),a._v(" "),t("h3",{attrs:{id:"_3-4-linkedhashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-linkedhashmap"}},[a._v("#")]),a._v(" 3.4 LinkedHashMap")]),a._v(" "),t("p",[a._v("使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用顺序。")]),a._v(" "),t("h2",{attrs:{id:"说说-list、set、queue、map-四者的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说说-list、set、queue、map-四者的区别"}},[a._v("#")]),a._v(" 说说 List、Set、Queue、Map 四者的区别？")]),a._v(" "),t("ul",[t("li",[a._v("List（对付顺序的好帮手）：存储的元素是有序的、可重复的。")]),a._v(" "),t("li",[a._v("Set（注重独一无二的性质）：存储的元素是无序的、不可重复的。")]),a._v(" "),t("li",[a._v("Queue（实现排队功能等等叫号机）：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。")]),a._v(" "),t("li",[a._v("Map（用key来搜索的专家）：使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。")])]),a._v(" "),t("h2",{attrs:{id:"集合框架底层数据结构总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集合框架底层数据结构总结"}},[a._v("#")]),a._v(" 集合框架底层数据结构总结")]),a._v(" "),t("p",[t("strong",[t("code",[a._v("Collection")]),a._v("接口下的集合：")])]),a._v(" "),t("ul",[t("li",[t("p",[t("strong",[a._v("List")])]),a._v(" "),t("ul",[t("li",[t("code",[a._v("ArrayList")]),a._v("："),t("code",[a._v("Object[]")]),a._v("数组")]),a._v(" "),t("li",[t("code",[a._v("Vector")]),a._v("："),t("code",[a._v("Object[]")]),a._v("数组")]),a._v(" "),t("li",[t("code",[a._v("LinkedList")]),a._v("：双向链表")])])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("Set")])]),a._v(" "),t("ul",[t("li",[t("code",[a._v("HashSet")]),a._v("（无序、唯一）：基于"),t("code",[a._v("HashMap")]),a._v("实现的，底层采用"),t("code",[a._v("HashMap")]),a._v("来保存元素")]),a._v(" "),t("li",[t("code",[a._v("LinkedHashSet")]),a._v("："),t("code",[a._v("LinkedHashSet")]),a._v("是"),t("code",[a._v("HashSet")]),a._v("的子类，并且其内部是通过"),t("code",[a._v("LinkedHashMap")]),a._v("来实现的。")]),a._v(" "),t("li",[t("code",[a._v("TreeSet")]),a._v("（有序、唯一）：红黑树（自平衡的排序二叉树）")])])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("Queue")])]),a._v(" "),t("ul",[t("li",[t("code",[a._v("PriorityQueue")]),a._v("："),t("code",[a._v("Object[]")]),a._v(" 数组来实现二叉堆")]),a._v(" "),t("li",[t("code",[a._v("ArrayQueue")]),a._v("："),t("code",[a._v("Object[]")]),a._v(" 数组 + 双指针")])])])]),a._v(" "),t("p",[t("strong",[t("code",[a._v("Map")]),a._v("接口下面的集合：")])]),a._v(" "),t("ul",[t("li",[t("code",[a._v("HashMap")]),a._v("：JDK1.8 之前 "),t("code",[a._v("HashMap")]),a._v(" 由数组+链表组成的，数组是 "),t("code",[a._v("HashMap")]),a._v(" 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。")]),a._v(" "),t("li",[t("code",[a._v("LinkedHashMap")]),a._v("："),t("code",[a._v("LinkedHashMap")]),a._v("继承自"),t("code",[a._v("HashMap")]),a._v("，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，"),t("code",[a._v("LinkedHashMap")]),a._v(" 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。")]),a._v(" "),t("li",[t("code",[a._v("Hashtable")]),a._v("：数组+链表组成，数组是"),t("code",[a._v("Hashtable")]),a._v("的主体，链表主要是为了解决哈希冲突而存在的。")]),a._v(" "),t("li",[t("code",[a._v("TreeMap")]),a._v("：红黑树（自平衡的排序二叉树）")])]),a._v(" "),t("h2",{attrs:{id:"如何选用集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何选用集合"}},[a._v("#")]),a._v(" 如何选用集合？")]),a._v(" "),t("p",[a._v("主要根据集合的特点来选用：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("需要根据键值获取到元素值时就选用 "),t("code",[a._v("Map")]),a._v(" 接口下的集合：")]),a._v(" "),t("ul",[t("li",[a._v("需要排序时选择 "),t("code",[a._v("TreeMap")])]),a._v(" "),t("li",[a._v("不需要排序时就选择 "),t("code",[a._v("HashMap")])]),a._v(" "),t("li",[a._v("需要保证线程安全就选用 "),t("code",[a._v("ConcurrentHashMap")]),a._v("。")])])]),a._v(" "),t("li",[t("p",[a._v("只需要存放元素值时，就选择实现"),t("code",[a._v("Collection")]),a._v(" 接口的集合：")]),a._v(" "),t("ul",[t("li",[a._v("需要保证元素唯一时选择实现 "),t("code",[a._v("Set")]),a._v(" 接口的集合比如 "),t("code",[a._v("TreeSet")]),a._v(" 或 "),t("code",[a._v("HashSet")])]),a._v(" "),t("li",[a._v("不需要保证元素唯一时就选择实现 "),t("code",[a._v("List")]),a._v(" 接口的比如 "),t("code",[a._v("ArrayList")]),a._v(" 或 "),t("code",[a._v("LinkedList")]),a._v("，然后再根据实现这些接口的集合的特点来选用。")])])])])])}),[],!1,null,null,null);e.default=v.exports}}]);