(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{480:function(_,v,s){"use strict";s.r(v);var t=s(14),n=Object(t.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h2",{attrs:{id:"_1、什么是关系型数据库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是关系型数据库"}},[_._v("#")]),_._v(" 1、什么是关系型数据库")]),_._v(" "),s("p",[_._v("关系型数据库就是一种建立在关系模型基础之上的数据库。关系模型表明了数据库中所有存储数据之间的联系（一对一、一对多、多对多）。")]),_._v(" "),s("h2",{attrs:{id:"_2、存储引擎"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、存储引擎"}},[_._v("#")]),_._v(" 2、存储引擎")]),_._v(" "),s("p",[s("strong",[_._v("查看MySQL提供的所有存储引擎：")])]),_._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[_._v("mysql"),s("span",{pre:!0,attrs:{class:"token operator"}},[_._v(">")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("show")]),_._v(" engines"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("p",[s("img",{attrs:{src:"/smallsunnyfox/images/mysql-engines.png",alt:"查看MySQL提供的所有存储引擎"}})]),_._v(" "),s("p",[_._v("从上图我们可以查看出 MySQL 当前默认的存储引擎是 InnoDB，并且在 5.7 版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。")]),_._v(" "),s("p",[s("strong",[_._v("查看MySQL当前默认的存储引擎：")])]),_._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[_._v("mysql"),s("span",{pre:!0,attrs:{class:"token operator"}},[_._v(">")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("show")]),_._v(" variables "),s("span",{pre:!0,attrs:{class:"token operator"}},[_._v("like")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[_._v("'%storage_engine%'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("p",[s("strong",[_._v("查看表的存储引擎：")])]),_._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("show")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("table")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("status")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[_._v("like")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[_._v('"table_name"')]),_._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br")])]),s("h3",{attrs:{id:"_2-1、myisam和inndb的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1、myisam和inndb的区别"}},[_._v("#")]),_._v(" 2.1、MyISAM和InnDB的区别")]),_._v(" "),s("p",[_._v("MySQL 5.5之前，MyISAM引擎是MySQL的默认存储引擎。")]),_._v(" "),s("p",[_._v("虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。")]),_._v(" "),s("p",[_._v("5.5 版本之后，MySQL 引入了 InnoDB（事务性数据库引擎），MySQL 5.5 版本后默认的存储引擎为 InnoDB。")]),_._v(" "),s("ol",[s("li",[s("p",[_._v("是否支持行级锁")]),_._v(" "),s("p",[_._v("MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。")]),_._v(" "),s("p",[_._v("也就说，MyISAM 一锁就是锁住了整张表。")])]),_._v(" "),s("li",[s("p",[_._v("是否支持事务")]),_._v(" "),s("p",[_._v("MyISAM 不提供事务支持。")]),_._v(" "),s("p",[_._v("InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。")])]),_._v(" "),s("li",[s("p",[_._v("是否支持外键")]),_._v(" "),s("p",[_._v("MyISAM 不支持，而 InnoDB 支持。")])]),_._v(" "),s("li",[s("p",[_._v("是否支持数据库异常奔溃后的安全恢复")]),_._v(" "),s("p",[_._v("MyISAM 不支持，而 InnoDB 支持。")]),_._v(" "),s("p",[_._v("使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo log 。")])]),_._v(" "),s("li",[s("p",[_._v("是否支持MVCC")]),_._v(" "),s("p",[_._v("MyISAM 不支持，而 InnoDB 支持。")]),_._v(" "),s("p",[_._v("MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。")])])]),_._v(" "),s("p",[_._v("💁‍♂扩展：")]),_._v(" "),s("ul",[s("li",[_._v("MySQL InnoDB 引擎使用 "),s("strong",[_._v("redo log(重做日志)")]),_._v(" 保证事务的"),s("strong",[_._v("持久性")]),_._v("，使用 "),s("strong",[_._v("undo log(回滚日志)")]),_._v(" 来保证事务的"),s("strong",[_._v("原子性")]),_._v("。")]),_._v(" "),s("li",[_._v("MySQL InnoDB 引擎通过 "),s("strong",[_._v("锁机制")]),_._v("、"),s("strong",[_._v("MVCC")]),_._v(" 等手段来保证事务的隔离性（ 默认支持的隔离级别是 "),s("strong",[s("code",[_._v("REPEATABLE-READ")])]),_._v(" ）。")]),_._v(" "),s("li",[_._v("保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。")])]),_._v(" "),s("h2",{attrs:{id:"_3、锁机制与innodb锁算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、锁机制与innodb锁算法"}},[_._v("#")]),_._v(" 3、锁机制与InnoDB锁算法")]),_._v(" "),s("p",[_._v("MyISAM 和 InnoDB 存储引擎使用的锁：")]),_._v(" "),s("ul",[s("li",[_._v("MyISAM 采用表级锁(table-level locking)。")]),_._v(" "),s("li",[_._v("InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁")])]),_._v(" "),s("p",[_._v("表级锁和行级锁对比：")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("表级锁：")]),_._v(" MySQL 中锁定 "),s("strong",[_._v("粒度最大")]),_._v(" 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。")]),_._v(" "),s("li",[s("strong",[_._v("行级锁：")]),_._v(" MySQL 中锁定 "),s("strong",[_._v("粒度最小")]),_._v(" 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。")])]),_._v(" "),s("p",[_._v("InnoDB 存储引擎的锁的算法有三种：")]),_._v(" "),s("ul",[s("li",[_._v("Record lock：记录锁，单个行记录上的锁")]),_._v(" "),s("li",[_._v("Gap lock：间隙锁，锁定一个范围，不包括记录本身")]),_._v(" "),s("li",[_._v("Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身")])]),_._v(" "),s("h2",{attrs:{id:"_4、事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、事务"}},[_._v("#")]),_._v(" 4、事务")]),_._v(" "),s("p",[_._v("事务是逻辑上的一组操作，要么都执行，要么都不执行。")]),_._v(" "),s("p",[_._v("数据库事务可以保证多个对数据库的操作（也就是SQL语句）构成一个逻辑上的整体。构成这个逻辑上整体的这些数据库操作遵循：要么全部执行成功，要么全部不执行。")]),_._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 开启一个事务")]),_._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("START")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("TRANSACTION")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 多条 SQL 语句")]),_._v("\nSQL1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v("SQL2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[_._v("## 提交事务")]),_._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("COMMIT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n\n")])]),_._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[_._v("1")]),s("br"),s("span",{staticClass:"line-number"},[_._v("2")]),s("br"),s("span",{staticClass:"line-number"},[_._v("3")]),s("br"),s("span",{staticClass:"line-number"},[_._v("4")]),s("br"),s("span",{staticClass:"line-number"},[_._v("5")]),s("br"),s("span",{staticClass:"line-number"},[_._v("6")]),s("br"),s("span",{staticClass:"line-number"},[_._v("7")]),s("br")])]),s("p",[_._v("关系型数据库事务都由ACID特性：")]),_._v(" "),s("ol",[s("li",[s("strong",[_._v("原子性")]),_._v("（"),s("code",[_._v("Atomicity")]),_._v("） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；")]),_._v(" "),s("li",[s("strong",[_._v("一致性")]),_._v("（"),s("code",[_._v("Consistency")]),_._v("）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；")]),_._v(" "),s("li",[s("strong",[_._v("隔离性")]),_._v("（"),s("code",[_._v("Isolation")]),_._v("）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；")]),_._v(" "),s("li",[s("strong",[_._v("持久性")]),_._v("（"),s("code",[_._v("Durability")]),_._v("）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。")])]),_._v(" "),s("p",[_._v("数据事务的实现原理：")]),_._v(" "),s("p",[_._v("以MySQL的InnoDB引擎为例")]),_._v(" "),s("ul",[s("li",[s("p",[_._v("MySQL InnoDB引擎使用redo log（重做日志）保证事务的持久性，使用undo log（回滚日志）来保证事务的原子性。")])]),_._v(" "),s("li",[s("p",[_._v("MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 "),s("code",[_._v("REPEATABLE-READ")]),_._v(" ）。")])]),_._v(" "),s("li",[s("p",[_._v("保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。")])])]),_._v(" "),s("h3",{attrs:{id:"_4-1、并发事务会带来哪些问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1、并发事务会带来哪些问题"}},[_._v("#")]),_._v(" 4.1、并发事务会带来哪些问题？")]),_._v(" "),s("p",[_._v("在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("脏读（Dirty read）:")]),_._v(" 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。")]),_._v(" "),s("li",[s("strong",[_._v("丢失修改（Lost to modify）:")]),_._v(" 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。")]),_._v(" "),s("li",[s("strong",[_._v("不可重复读（Unrepeatable read）:")]),_._v(" 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。")]),_._v(" "),s("li",[s("strong",[_._v("幻读（Phantom read）:")]),_._v(" 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。")])]),_._v(" "),s("p",[_._v("不可重复读和幻读的区别：")]),_._v(" "),s("ul",[s("li",[s("p",[_._v("不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改。")])]),_._v(" "),s("li",[s("p",[_._v("幻读的重点在于新增或删除比如多次读取一条记录发现记录增多或减少了。")])])]),_._v(" "),s("h3",{attrs:{id:"_4-2、事务隔离级别有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2、事务隔离级别有哪些"}},[_._v("#")]),_._v(" 4.2、事务隔离级别有哪些？")]),_._v(" "),s("p",[s("strong",[_._v("SQL标准定义了四个隔离级别：")])]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("READ-UNCOMMITTED(读取未提交)：")]),_._v(" 最低的隔离级别，允许读取尚未提交的数据变更，"),s("strong",[_._v("可能会导致脏读、幻读或不可重复读")]),_._v("。")]),_._v(" "),s("li",[s("strong",[_._v("READ-COMMITTED(读取已提交)：")]),_._v(" 允许读取并发事务已经提交的数据，"),s("strong",[_._v("可以阻止脏读，但是幻读或不可重复读仍有可能发生")]),_._v("。")]),_._v(" "),s("li",[s("strong",[_._v("REPEATABLE-READ(可重复读)：")]),_._v(" 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，"),s("strong",[_._v("可以阻止脏读和不可重复读，但幻读仍有可能发生")]),_._v("。")]),_._v(" "),s("li",[s("strong",[_._v("SERIALIZABLE(可串行化)：")]),_._v(" 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，"),s("strong",[_._v("该级别可以防止脏读、不可重复读以及幻读")]),_._v("。")])]),_._v(" "),s("table",[s("thead",[s("tr",[s("th",[_._v("隔离级别")]),_._v(" "),s("th",[_._v("脏读")]),_._v(" "),s("th",[_._v("不可重复读")]),_._v(" "),s("th",[_._v("幻读")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("READ-UNCOMMITTED")]),_._v(" "),s("td",[_._v("√")]),_._v(" "),s("td",[_._v("√")]),_._v(" "),s("td",[_._v("√")])]),_._v(" "),s("tr",[s("td",[_._v("READ-COMMITTED")]),_._v(" "),s("td",[_._v("×")]),_._v(" "),s("td",[_._v("√")]),_._v(" "),s("td",[_._v("√")])]),_._v(" "),s("tr",[s("td",[_._v("REPEATABLE-READ")]),_._v(" "),s("td",[_._v("×")]),_._v(" "),s("td",[_._v("×")]),_._v(" "),s("td",[_._v("√")])]),_._v(" "),s("tr",[s("td",[_._v("SERIALIZABLE")]),_._v(" "),s("td",[_._v("×")]),_._v(" "),s("td",[_._v("×")]),_._v(" "),s("td",[_._v("×")])])])]),_._v(" "),s("p",[s("strong",[_._v("MySQL默认的隔离级别是什么？")])]),_._v(" "),s("p",[_._v("MySQL InnoDB 存储引擎的默认支持的隔离级别是 "),s("strong",[_._v("REPEATABLE-READ（可重读）")]),_._v("。我们可以通过"),s("code",[_._v("SELECT @@tx_isolation;")]),_._v("命令来查看，MySQL 8.0 该命令改为"),s("code",[_._v("SELECT @@transaction_isolation;")])]),_._v(" "),s("p",[_._v("因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是"),s("strong",[_._v("READ-COMMITTED(读取提交内容)")]),_._v(" 。但InnoDB存储引擎默认使用 "),s("strong",[_._v("REPEATABLE-READ（可重读）")]),_._v(" 并不会有任何性能损失。")]),_._v(" "),s("p",[_._v("InnoDB 存储引擎在 "),s("strong",[_._v("分布式事务")]),_._v(" 的情况下一般会用到 "),s("strong",[_._v("SERIALIZABLE(可串行化)")]),_._v("  隔离级别。")]),_._v(" "),s("p",[_._v("MySQL InnoDB的 "),s("strong",[_._v("REPEATABLE-READ（可重读）")]),_._v(" 并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用的机制就是 "),s("strong",[_._v("Next-Key Locks。")])])])}),[],!1,null,null,null);v.default=n.exports}}]);