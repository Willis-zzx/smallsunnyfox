(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{486:function(_,v,n){"use strict";n.r(v);var t=n(14),a=Object(t.a)({},(function(){var _=this,v=_.$createElement,n=_._self._c||v;return n("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[n("h2",{attrs:{id:"innodb"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#innodb"}},[_._v("#")]),_._v(" InnoDB")]),_._v(" "),n("p",[n("strong",[_._v("是 MySQL 默认的事务型存储引擎")]),_._v("，只有在需要它不支持的特性时，才考虑使用其它存储引擎。")]),_._v(" "),n("p",[_._v("实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+间隙锁（Next-Key Locking）防止幻影读。")]),_._v(" "),n("p",[_._v("主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。")]),_._v(" "),n("p",[_._v("内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。")]),_._v(" "),n("p",[_._v("支持真正的在线热备份。其他存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。")]),_._v(" "),n("p",[_._v("四种隔离级别：")]),_._v(" "),n("ol",[n("li",[_._v("Read Uncommitted（读取未提交内容）：在该隔离级别中，所有事务都可以看到其他未提交事务的执行结果。\n本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。\n读取未提交的数据，也被称之为脏读。")]),_._v(" "),n("li",[_._v("Read Committed（读取提交内容）：**这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。**它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。\n这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理期间可能会有新的 commit，所以同一 select 可能返回不同结果。")]),_._v(" "),n("li",[_._v("Repeatable Read（可重复读）："),n("strong",[_._v("这是 MySQL 默认的事务隔离级别")]),_._v("，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。\n不过理论上，这会导致另外一个棘手的问题：幻读（PhantomRead）。\n幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”行。\nInnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。")]),_._v(" "),n("li",[_._v("Serializable（可串行化）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。它是在每个读的数据行上加上共享锁。在这个级别，可能会导致大量的超时现象和锁竞争。")])]),_._v(" "),n("h2",{attrs:{id:"myisam"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#myisam"}},[_._v("#")]),_._v(" MyISAM")]),_._v(" "),n("p",[_._v("设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。")]),_._v(" "),n("p",[_._v("提供了大量的特性，包括压缩表、空间数据索引等。")]),_._v(" "),n("p",[n("strong",[_._v("不支持事务。")])]),_._v(" "),n("p",[_._v("不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。")]),_._v(" "),n("p",[_._v("可以手工或自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能会导致一些数据丢失，而且修复操作是非常慢的。")]),_._v(" "),n("p",[_._v("如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。")]),_._v(" "),n("h2",{attrs:{id:"比较"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#比较"}},[_._v("#")]),_._v(" 比较")]),_._v(" "),n("ul",[n("li",[_._v("事务：InnoDB 是事务型的，可以使用 commit 和 Rollback 语句。")]),_._v(" "),n("li",[_._v("并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。")]),_._v(" "),n("li",[_._v("外键：InnoDB 支持外键。")]),_._v(" "),n("li",[_._v("备份：InnoDB 支持在线热备份。")]),_._v(" "),n("li",[_._v("崩溃恢复：MyISAM 崩溃后发生损坏的概率也比 InnoDB 高很多，而且恢复的速度也更慢。")]),_._v(" "),n("li",[_._v("其他特性：MyISAM 支持压缩表和空间数据索引。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);