(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{489:function(s,e,a){"use strict";a.r(e);var t=a(14),r=Object(t.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"分布式缓存常见的技术选型方案有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式缓存常见的技术选型方案有哪些"}},[s._v("#")]),s._v(" 分布式缓存常见的技术选型方案有哪些")]),s._v(" "),a("p",[s._v("分布式缓存使用比较多的是 Memcahed 和 Redis 。现在项目多数用到 Redis。\n分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用信息的问题。因为本地缓存只在当前服务里有效。")]),s._v(" "),a("h2",{attrs:{id:"redis-和-memcached-的区别和共同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-和-memcached-的区别和共同点"}},[s._v("#")]),s._v(" Redis 和 Memcached 的区别和共同点")]),s._v(" "),a("p",[s._v("现在项目基本使用 Redis 来实现缓存。\n共同点：")]),s._v(" "),a("ol",[a("li",[s._v("都是基于内存的数据库，一般都当作缓存来使用。")]),s._v(" "),a("li",[s._v("都有过期策略")]),s._v(" "),a("li",[s._v("两者的性能都非常高")])]),s._v(" "),a("p",[s._v("不同点：")]),s._v(" "),a("ol",[a("li",[s._v("Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，还提供了list 、set、zset、hash四种数据结构的存储。Memcached 只支持简单的 k/v 数据类型。")]),s._v(" "),a("li",[s._v("Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载使用，而 Memcached 把数据完全存在内存中。")]),s._v(" "),a("li",[s._v("Redis 有灾难容灾机制。因为可以把缓存中的数据持久化到磁盘中。")]),s._v(" "),a("li",[s._v("Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘中。Memcached 在服务器内存使用完之后会直接报异常。")]),s._v(" "),a("li",[s._v("Mencached 没有原生的集群模式，需要依靠客户端来实现集群中分片写入数据。Redis 目前是原生支持 cluster 模式的。")]),s._v(" "),a("li",[s._v("Memcached 是多线程，非阻塞 IO 复用的网络模型。Redis使用单线程的多路 IO 复用模型。")]),s._v(" "),a("li",[s._v("Redis 支持发布订阅、Lua 脚本、事务等功能，而 Mencached不支持，并且 Redis 支持更多的编程语言。")]),s._v(" "),a("li",[s._v("Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。")])]),s._v(" "),a("h2",{attrs:{id:"缓存处理流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存处理流程"}},[s._v("#")]),s._v(" 缓存处理流程")]),s._v(" "),a("p",[s._v("请求的数据在缓存中就直接返回。\n缓存中不存在就看数据库中是否存在。\n数据库中存在就更新缓存中的数据。\n数据库中不存在就返回空数据。")]),s._v(" "),a("h2",{attrs:{id:"为什么要使用-redis-为什么要使用缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用-redis-为什么要使用缓存"}},[s._v("#")]),s._v(" 为什么要使用 Redis/为什么要使用缓存")]),s._v(" "),a("p",[s._v("高性能：将经常使用的数据放入缓存，可提供系统获取数据的速度。\n高并发：一般像MySQL这类数据库的QPS（服务器每秒可以执行的查询次数）大概在1w左右（4核8g），但使用 Redis 缓存后很容易达到10w+，最高能到30w+。由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，把数据库中部分数据转移到缓存中，一部分请求会直接到缓存而不用经过数据库，这样也就提高了系统整体的并发。")]),s._v(" "),a("h2",{attrs:{id:"redis-除了做缓存-还能做什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-除了做缓存-还能做什么"}},[s._v("#")]),s._v(" Redis 除了做缓存，还能做什么")]),s._v(" "),a("ul",[a("li",[s._v("分布锁")]),s._v(" "),a("li",[s._v("限流：一般是通过 Redis + Lua 就脚本的方式实现限流。")]),s._v(" "),a("li",[s._v("消息队列：Redis 自带的 list 数据结构可以作为一个简单的队列使用。")]),s._v(" "),a("li",[s._v("复杂业务场景：....")])]),s._v(" "),a("h2",{attrs:{id:"redis-单线程模型详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-单线程模型详解"}},[s._v("#")]),s._v(" Redis 单线程模型详解")]),s._v(" "),a("p",[a("strong",[s._v("Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型（Netty 的线程模型也是基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石）")])]),s._v(" "),a("p",[a("strong",[s._v("这套事件处理模型对应的是 Redis 中的文件事件处理器。由于文件事件处理器是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。")])]),s._v(" "),a("p",[a("strong",[s._v("既然是单线程，那怎么监听大量的客户端连接呢？")])]),s._v(" "),a("p",[s._v("Redis 通过 "),a("strong",[s._v("IO")]),s._v(" "),a("strong",[s._v("多路复用程序")]),s._v(" 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发送。")]),s._v(" "),a("p",[s._v("这样的好处非常明显：I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。")]),s._v(" "),a("p",[s._v("另外，Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：")]),s._v(" "),a("ol",[a("li",[s._v("文件事件（客户端进行读取写入等操作，涉及一系列网络通信）")]),s._v(" "),a("li",[s._v("时间事件")])]),s._v(" "),a("blockquote",[a("p",[s._v("Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。")]),s._v(" "),a("p",[s._v("文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。")]),s._v(" "),a("p",[s._v("当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。")]),s._v(" "),a("p",[s._v("虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。《Redis 设计与介绍》")])]),s._v(" "),a("p",[s._v("可以看出，文件事件处理器（file event handler）主要是包含4个部分：")]),s._v(" "),a("ul",[a("li",[s._v("多个 socket （客户端连接）")]),s._v(" "),a("li",[s._v("IO 多路复用程序（支持多个客户端连接的关键）")]),s._v(" "),a("li",[s._v("文件事件分派器（将 socket 关联到相应的事件处理器）")]),s._v(" "),a("li",[s._v("事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Willis-zzx/PicGO/img/202202261741133.png",alt:"img"}})]),s._v(" "),a("h2",{attrs:{id:"redis-没有使用多线程-为什么不使用多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-没有使用多线程-为什么不使用多线程"}},[s._v("#")]),s._v(" Redis 没有使用多线程？为什么不使用多线程？")]),s._v(" "),a("p",[s._v("虽然说 Redis 是单线程模型，实际上，"),a("strong",[s._v("Redis 在4.0之后的版本中就已经加入了对多线程的支持。")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Willis-zzx/PicGO/img/202202261741988.png",alt:"redis4.0 more thread"}})]),s._v(" "),a("p",[s._v("不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。")]),s._v(" "),a("p",[s._v("大体上来上，"),a("strong",[s._v("Redis 6.0 之前主要还是单线程处理。")])]),s._v(" "),a("p",[s._v("那么，Redis 6.0 之前为什么不使用多线程？")]),s._v(" "),a("ol",[a("li",[s._v("单线程编程容易并且更容易维护；")]),s._v(" "),a("li",[s._v("Redis 的性能瓶颈不在 CPU，主要在内存和网络；")]),s._v(" "),a("li",[s._v("多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。")])]),s._v(" "),a("h2",{attrs:{id:"redis-6-0-之后为何引入了多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-6-0-之后为何引入了多线程"}},[s._v("#")]),s._v(" Redis 6.0 之后为何引入了多线程？")]),s._v(" "),a("p",[a("strong",[s._v("Redis 6.0 引入多线程主要是为了提高网络 IO 读写性能。")])]),s._v(" "),a("p",[s._v("因为这也算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要是受限于内存和网络）。")]),s._v(" "),a("p",[s._v("虽然，Redis 6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用，执行命令仍然是单线程顺序执行，因此不需要担心线程安全问题。")]),s._v(" "),a("p",[s._v("Redis 6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 Redis 配置文件 redis.conf ：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("io-threads-do-reads "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 Redis 配置文件 redis.conf ：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("io-threads "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("##官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("推荐阅读：")]),s._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw",target:"_blank",rel:"noopener noreferrer"}},[s._v("Redis 6.0 新特性-多线程连环 13 问"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://draveness.me/whys-the-design-redis-single-thread/",target:"_blank",rel:"noopener noreferrer"}},[s._v("为什么 Redis 选择单线程模型"),a("OutboundLink")],1)])]),s._v(" "),a("h2",{attrs:{id:"redis-给缓存数据设置过期时间有啥用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-给缓存数据设置过期时间有啥用"}},[s._v("#")]),s._v(" Redis 给缓存数据设置过期时间有啥用？")]),s._v(" "),a("p",[s._v("一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间，为什么？")]),s._v(" "),a("p",[s._v("因为内存是有限的，如果缓存中的所有数据都是一直保存的话，会造成内存不足。")]),s._v(" "),a("p",[s._v("Redis 自带了给缓存设置过期时间的功能，比如：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),a("span",{pre:!0,attrs:{class:"token operator"}},[a("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v(" exp key "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("60")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("## 数据在 60s 后过期")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("integer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),a("span",{pre:!0,attrs:{class:"token operator"}},[a("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v(" setex key "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("60")]),s._v(" value "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("## 数据在 60s 后过期 (setex:[set] + [ex]pire)")]),s._v("\nOK\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),a("span",{pre:!0,attrs:{class:"token operator"}},[a("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v(" ttl key "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("## 查看数据还有多久过期")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("integer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("56")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("注意：Redis 中除了字符串类型有自己独有的设置过期时间的命令 setex 之外，其他类型都需要依靠 expire 命令来设置过期时间。另外， persist 命令可以移除一个键的过期时间。")]),s._v(" "),a("p",[a("strong",[s._v("过期时间除了有助于缓解内存的消耗，还有什么其他用处吗？")])]),s._v(" "),a("p",[s._v("很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。")]),s._v(" "),a("p",[s._v("如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。")]),s._v(" "),a("h2",{attrs:{id:"redis-是如何判断数据是否过期的呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-是如何判断数据是否过期的呢"}},[s._v("#")]),s._v(" Redis 是如何判断数据是否过期的呢？")]),s._v(" "),a("p",[s._v("Redis 通过一个叫做 过期字典 （可以看作 hash 表）来保存数据过期的时间。")]),s._v(" "),a("p",[s._v("过期字典的键指向 Redis 数据库中的某个 key（键），过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Willis-zzx/PicGO/img/202202261742687.png",alt:"redis过期字典"}})]),s._v(" "),a("p",[s._v("过期字典是存储在 redisDb 这个结构里的：")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("typedef")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("redisDb")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("\n\n    dict "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("dict"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("     "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//数据库键空间,保存着数据库中所有键值对")]),s._v("\n    dict "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("expires   "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 过期字典,保存着键的过期时间")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" redisDb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h2",{attrs:{id:"过期的数据的删除策略了解么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过期的数据的删除策略了解么"}},[s._v("#")]),s._v(" 过期的数据的删除策略了解么？")]),s._v(" "),a("p",[s._v("如果假设设置了一批 key 只能存活一分钟，那么一分钟后，"),a("strong",[s._v("Redis 是怎么对这批 key 进行删除的？")])]),s._v(" "),a("p",[s._v("常用的过期数据的删除策略有两个：")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("惰性删除：")]),s._v(" 只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。")]),s._v(" "),a("li",[a("strong",[s._v("定期删除：")]),s._v(" 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。")])]),s._v(" "),a("p",[s._v("定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 "),a("strong",[s._v("定期删除+惰性、懒汉式删除。")])]),s._v(" "),a("p",[s._v("但是，仅仅通过给 key 设置过期时间还是有问题的。")]),s._v(" "),a("p",[s._v("因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就会导致大量过期 key 堆积在内存里，然后就 Out of memory 了。")]),s._v(" "),a("p",[s._v("这个问题的解决方案是："),a("strong",[s._v("Redis 内存淘汰机制。")])]),s._v(" "),a("h2",{attrs:{id:"redis-内存淘汰机制是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-内存淘汰机制是什么"}},[s._v("#")]),s._v(" Redis 内存淘汰机制是什么？")]),s._v(" "),a("blockquote",[a("p",[s._v("相关问题：MySQL 里有 2000w 数据，Redis 中只有 20w 的数据，如何保证 Redis 中的数据都是热点数据？")])]),s._v(" "),a("p",[s._v("Redis 提供了6中数据淘汰策略：")]),s._v(" "),a("ol",[a("li",[a("p",[a("strong",[s._v("volatile-lru（least recently used）：")]),s._v(" 从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。")])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("volatile-ttl：")]),s._v(" 从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。")])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("volatile-random：")]),s._v(" 从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。")])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("allkeys-lru（least recently used）：")]),s._v(" 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。")])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("allkeys-random：")]),s._v(" 从数据集（server.db[i].dict）中任意选择数据淘汰。")])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("no-eviction：")]),s._v(" 禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！")]),s._v(" "),a("p",[s._v("4.0 版本后增加以下两种：")])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("volatile-lfu（least frequently used）：")]),s._v(" 从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。")])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("allkeys-lfu（least frequently used）：")]),s._v(" 当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。")])])]),s._v(" "),a("h2",{attrs:{id:"redis-持久化机制-怎么保证-redis-挂掉后再重启数据可以进行恢复"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化机制-怎么保证-redis-挂掉后再重启数据可以进行恢复"}},[s._v("#")]),s._v(" Redis 持久化机制（怎么保证 Redis 挂掉后再重启数据可以进行恢复）")]),s._v(" "),a("p",[s._v("很多时候我们需要持久化数据，也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。")]),s._v(" "),a("p",[s._v("Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。"),a("strong",[s._v("Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）。")])]),s._v(" "),a("ul",[a("li",[a("p",[a("strong",[s._v("快照持久化（RDB）")])]),s._v(" "),a("p",[s._v("Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。")]),s._v(" "),a("p",[s._v("快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有如下配置：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("save "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("900")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("           "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("##在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。")]),s._v("\n\nsave "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("300")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("          "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("##在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。")]),s._v("\n\nsave "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("60")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10000")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("##在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("AOF（append-only file）持久化（AOF）")])]),s._v(" "),a("p",[s._v("与快照持久化相比，AOF 持久化的实时性更好，因此已经成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append-only file） 方式的持久化，可以通过 appendonly 参数开启：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("appendonly "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。")]),s._v(" "),a("p",[s._v("AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof 。")]),s._v(" "),a("p",[s._v("在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，分别是：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("appendfsync always    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("##每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度")]),s._v("\nappendfsync everysec  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("##每秒钟同步一次，显式地将多个写命令同步到硬盘")]),s._v("\nappendfsync no        "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("##让操作系统决定何时进行同步")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统奔溃，用户最多只会丢失一秒内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。")])])]),s._v(" "),a("p",[a("strong",[s._v("Redis 4.0 对于持久化机制的优化：")])]),s._v(" "),a("p",[s._v("Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。")]),s._v(" "),a("p",[s._v("如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。")]),s._v(" "),a("ul",[a("li",[s._v("这样做的好处是可以结合 RDB 和 AOF 的优点，快速加载同时避免丢失过多的数据。")]),s._v(" "),a("li",[s._v("当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。")])]),s._v(" "),a("p",[a("strong",[s._v("AOF 重写：")])]),s._v(" "),a("p",[s._v("AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。")]),s._v(" "),a("p",[s._v("AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。")]),s._v(" "),a("p",[s._v("在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。")])])}),[],!1,null,null,null);e.default=r.exports}}]);