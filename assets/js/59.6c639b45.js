(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{492:function(s,a,e){"use strict";e.r(a);var t=e(14),v=Object(t.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"redis-持久化简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化简介"}},[s._v("#")]),s._v(" Redis 持久化简介")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("为什么需要持久化")]),s._v(" "),e("p",[s._v("Redis 是一个基于内存的数据库，服务器一旦宕机，内存中的数据就会全部丢失。")]),s._v(" "),e("p",[s._v("通常的解决方案是从后端数据库恢复这些数据，但后端数据库有性能瓶颈，如果是大数据量的恢复：1.会对数据库带来巨大的压力；2.数据库的性能不如 Redis。导致程序响应慢。所以对 Redis 来说，实现数据的持久化，避免从后端数据库中恢复数据，是至关重要的。")])]),s._v(" "),e("li",[e("p",[s._v("Redis 持久化有哪些方式？为什么重点学习 RDB 和 AOF？")]),s._v(" "),e("p",[s._v("从严格意义上说，Redis 服务提供四种持久化存储方案：RDB、AOF、虚拟内存（VM）和　DISKSTORE。")]),s._v(" "),e("p",[s._v("虚拟内存（VM）方式，从 Redis Version 2.4 开始就被官方明确表示不再建议使用，Version 3.2版本中更找不到关于虚拟内存（VM）的任何配置范例。")]),s._v(" "),e("p",[s._v("至于 DISKSTORE 方式，是从 Redis Version 2.8 版本开始提出的一个存储设想，到目前为止 Redis 官方也没有在任何 stable 版本中明确建议使用这用方式。在 Version 3.2 版本中同样找不到对于这种存储方式的明确支持。")]),s._v(" "),e("p",[s._v("最关键的是目前官方文档上能够看到的 Redis 对持久化存储的支持明确的就只有两种方案（https://redis.io/topics/persistence）：RDB 和 AOF。")])])]),s._v(" "),e("h2",{attrs:{id:"rdb-持久化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rdb-持久化"}},[s._v("#")]),s._v(" RDB 持久化")]),s._v(" "),e("p",[s._v("RDB 持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。")]),s._v(" "),e("h3",{attrs:{id:"触发方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#触发方式"}},[s._v("#")]),s._v(" 触发方式")]),s._v(" "),e("p",[s._v("手动触发和自动触发")]),s._v(" "),e("h4",{attrs:{id:"手动触发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手动触发"}},[s._v("#")]),s._v(" 手动触发")]),s._v(" "),e("ul",[e("li",[s._v("save 命令：阻塞当前 Redis 服务器，直到 RDB 过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。")]),s._v(" "),e("li",[s._v("bgsave 命令：Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。")])]),s._v(" "),e("p",[s._v("bgsave 流程图如下：")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Willis-zzx/PicGO/img/202204132241299.png",alt:""}})]),s._v(" "),e("p",[s._v("具体流程如下：")]),s._v(" "),e("ul",[e("li",[s._v("redis 客户端执行 bgsave 命令或者自动触发 bgsave 命令；")]),s._v(" "),e("li",[s._v("主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；")]),s._v(" "),e("li",[s._v("如果不存在正在执行的子进程，那么就 fork 一个新的子进程进行持久化数据，fork过程是阻塞的，fork 操作完成后主进程即可执行其他操作；")]),s._v(" "),e("li",[s._v("子进程先将数据写入到临时的 rdb 文件中，待快照数据写入完成后再原子替换旧的 rdb文件；")]),s._v(" "),e("li",[s._v("同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项）。")])]),s._v(" "),e("h4",{attrs:{id:"自动触发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自动触发"}},[s._v("#")]),s._v(" 自动触发")]),s._v(" "),e("p",[s._v("在以下四种情况时会自动触发：")]),s._v(" "),e("ul",[e("li",[s._v("redis.conf 中配置 save m n，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；")]),s._v(" "),e("li",[s._v("主从复制时，从节点要从主节点进行全量复制时也会触发 bgsave 操作，生成当时的快照发送到从节点；")]),s._v(" "),e("li",[s._v("执行 debug reload 命令重新加载 redis 时也会触发 bgsave 操作；")]),s._v(" "),e("li",[s._v("默认情况下执行 shutdown 命令时，如果没有开启 aof 持久化，那么也会触发 bgsave 操作；")])]),s._v(" "),e("h3",{attrs:{id:"redis-conf-中配置-rdb"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-conf-中配置-rdb"}},[s._v("#")]),s._v(" redis.conf 中配置 RDB")]),s._v(" "),e("p",[s._v("快照周期：内存快照虽然可以通过技术人员手动执行 save 或 bgsave 命令来执行，但生产环境下多数都会设置其周期性执行条件。")]),s._v(" "),e("p",[s._v("Redis 中默认的周期性设置：")]),s._v(" "),e("div",{staticClass:"language-sh line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 周期性执行条件的设置格式为")]),s._v("\nsave "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("seconds"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("changes"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 默认的设置为：")]),s._v("\nsave "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("900")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\nsave "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("300")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("\nsave "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("60")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10000")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 以下设置方式为关闭RDB快照功能")]),s._v("\nsave "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v('""')]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br")])]),e("p",[s._v("以上三项默认信息设置代表的意义是：")]),s._v(" "),e("ul",[e("li",[s._v("如果900秒内有1条Key信息发生变化，则进行快照；")]),s._v(" "),e("li",[s._v("如果300秒内有10条Key信息发生变化，则进行快照；")]),s._v(" "),e("li",[s._v("如果60秒内有10000条Key信息发生变化，则进行快照。读者可以按照这个规则，根据自己的实际请求压力进行设置调整")])]),s._v(" "),e("p",[s._v("其他相关配置：")]),s._v(" "),e("div",{staticClass:"language-sh line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 文件名称")]),s._v("\ndbfilename dump.rdb\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 文件保存路径")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("dir")]),s._v(" /home/work/app/redis/data/\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 如果持久化出错，主进程是否停止写入")]),s._v("\nstop-writes-on-bgsave-error "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 是否压缩")]),s._v("\nrdbcompression "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 导入时是否检查")]),s._v("\nrdbchecksum "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("yes")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br")])]),e("ul",[e("li",[s._v("dbfilename：RDB 文件在磁盘上的名称。")]),s._v(" "),e("li",[s._v("dir：RDB 文件的存储路径。默认设置为“./”，也就是Redis服务的主目录。")]),s._v(" "),e("li",[s._v("stop-writes-on-bgsave-error：上文提到的在快照进行过程中，主进程照样可以接受客户端的任何写操作的特性，是指在快照操作正常的情况下。如果快照操作出现异常（例如操作系统用户权限不够、磁盘空间写满等等）时，Redis就会禁止写操作。这个特性的主要目的是使运维人员在第一时间就发现Redis的运行错误，并进行解决。一些特定的场景下，您可能需要对这个特性进行配置，这时就可以调整这个参数项。该参数项默认情况下值为yes，如果要关闭这个特性，指定即使出现快照错误Redis一样允许写操作，则可以将该值更改为no。")]),s._v(" "),e("li",[s._v("rdbcompression：该属性将在字符串类型的数据被快照到磁盘文件时，启用LZF压缩算法。Redis官方的建议是请保持该选项设置为yes，因为“it’s almost always a win”。 rdbchecksum：从RDB快照功能的version 5 版本开始，一个64位的CRC冗余校验编码会被放置在RDB文件的末尾，以便对整个RDB文件的完整性进行验证。这个功能大概会多损失10%左右的性能，但获得了更高的数据可靠性。所以如果您的Redis服务需要追求极致的性能，就可以将这个选项设置为no")])]),s._v(" "),e("h3",{attrs:{id:"深入理解-rdb"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深入理解-rdb"}},[s._v("#")]),s._v(" 深入理解 RDB")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("由于生产环境中我们为 Redis 开辟的内存区域都比较大（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间 Redis 服务一般都会收到数据写操作请求。那么如何保证数据一致性呢？")]),s._v(" "),e("p",[s._v("RDB 中的核心思路是 Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面 Redis 主进程会 fork 一个新的快照进程专门来做这个事情，这样保证了 Redis 服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。")]),s._v(" "),e("p",[s._v("举个例子：如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。")])])]),s._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Willis-zzx/PicGO/img/202204132241152.png",alt:""}})]),s._v(" "),e("ul",[e("li",[e("p",[s._v("在进行快照操作的这段时间，如果发生服务崩溃怎么办？")]),s._v(" "),e("p",[s._v("在没有将数据全部写入到磁盘前，这次快照操作都不算成功。如果出现了服务崩溃的情况，将以上一次完整的 RDB 快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis 服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。")])]),s._v(" "),e("li",[e("p",[s._v("可以每秒做一次快照吗？")]),s._v(" "),e("p",[s._v("虽然每次快照都是由 bgsave 子进程在后台执行，不会阻塞主线程，但如果频繁地执行全量快照，会带来两方面的开销：")]),s._v(" "),e("ul",[e("li",[s._v("一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘宽带，前一个快照还没做完，后一个又开始做了，容易造成恶性循环。")]),s._v(" "),e("li",[s._v("另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是 fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。")])]),s._v(" "),e("p",[s._v("那么，有什么其他好方法吗？可以做增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。")]),s._v(" "),e("p",[s._v("但这种方式需要使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。")]),s._v(" "),e("p",[s._v("那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销坐到尽量少丢数据：RDB 和 AOF 结合。")])])]),s._v(" "),e("h3",{attrs:{id:"rdb-优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rdb-优缺点"}},[s._v("#")]),s._v(" RDB 优缺点")]),s._v(" "),e("ul",[e("li",[s._v("优点\n"),e("ul",[e("li",[s._v("RDB 文件是某个时间点的快照，默认使用 LZF 算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；")]),s._v(" "),e("li",[s._v("Redis 加载 RDB 文件恢复数据要远远快于 AOF 方式；")])])]),s._v(" "),e("li",[s._v("缺点\n"),e("ul",[e("li",[s._v("RDB 方式实时性不够，无法坐到秒级的持久化；")]),s._v(" "),e("li",[s._v("每次调用 bgsave 都需要 fork 子进程，fork 子进程属于重量级操作，频繁执行成本较高；")]),s._v(" "),e("li",[s._v("RDB 文件是二进制，没有可读性，AOF 文件在了解其结构的情况下可以手动修改或者补全；")]),s._v(" "),e("li",[s._v("版本兼容 RDB 文件问题；")])])])]),s._v(" "),e("p",[s._v("针对 RDB 不适合实时持久化的问题，Redis 提供了 AOF 持久化方式来解决。")]),s._v(" "),e("h2",{attrs:{id:"aof-持久化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aof-持久化"}},[s._v("#")]),s._v(" AOF 持久化")]),s._v(" "),e("p",[s._v("Redis 是“写后”日志，Redis 先执行命令，把数据写入内存，然后才记录日志。")]),s._v(" "),e("p",[s._v("日志里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存。")]),s._v(" "),e("p",[s._v("AOF 采用“写后”日志，即先写内存，再写日志。")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Willis-zzx/PicGO/img/202204132242292.png",alt:""}})])])}),[],!1,null,null,null);a.default=v.exports}}]);